# head first 设计模式
### 设计原则： 
- 多用组合少用继承。
- 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混合在一起。
- 针对接口编程，而不是针对实现编程。
- 为了交互对象之间的松耦合设计而努力。
- 类应该对扩展开放，对修改关闭。
- 要依赖抽象，不要依赖具体类。
- 最少知识原则：只和你的密友谈话。（相当于类间交互适当封装，减少耦合，只让必要部分交互）
- 好莱坞原则：别调用我们，我们会调用你。（高层组件控制何时调用底层组件）
- 一个类应该只有一个引起改变的原因。（使一个类具有单一的责任，避免类的改变引起大范围的修改，实现类的高内聚）

### 策略模式
- 定义：定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
- 例子： 鸭子有不同的品种，但是它们都会鸣叫，有不同的鸣叫方式。
![avatar](http://dl2.iteye.com/upload/attachment/0093/6873/97871e8f-0d17-33f9-968d-dd05769b67fa.jpg)


### 观察者模式
- 定义：定义了对象之间的一对多依赖，这样一来，当一个对象的状态改变时，他的所有依赖着都会受到通知并自动更新。
- 其中java中有内置观察者模式的接口，java.util.Observer和java.util.Observable。缺点就是无法在通知时自定义一些行为。
- 例子：气象站与布告板，气象站的温度改变，布告板就需要知道改变的温度。
![avatar](https://www.runoob.com/wp-content/uploads/2014/08/observer_pattern_uml_diagram.jpg)

### 装饰者模式
- 定义：定义动态地将责任附加到对象上。若要拓展功能，装饰着提供了比集成更有弹性的替代方案。
- 例子：饮料分为多种，添加不同的调料，支持调料多次添加。设置调料味装饰者。
- java中的例子java IO类，FilterInputStream为一个装饰者。
![avatar](https://img2018.cnblogs.com/blog/1216886/201909/1216886-20190922012926406-314109345.png)

![avatar](https://img2018.cnblogs.com/blog/1216886/201909/1216886-20190922011430803-958922094.png)

### 工厂模式
- 定义：定义一个创建对象的接口，但由子类觉得要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。
![avatar](https://www.runoob.com/wp-content/uploads/2014/08/AB6B814A-0B09-4863-93D6-1E22D6B07FF8.jpg)

### 抽象工厂模式
- 定义：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。
![avatar](https://www.runoob.com/wp-content/uploads/2014/08/3E13CDD1-2CD2-4C66-BD33-DECBF172AE03.jpg)

### 单件模式（单例）
- 定义：确保一个类只有一个实例，并提供一个全局的访问点。

### 命令模式
- 定义：定义将"请求"封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。
- 例子：

1. 餐厅点菜场景: 顾客点菜创建Command，交给服务员Waiter，服务员invoke命令。命令中包含完成改命令的厨师对象，厨师接收到命令开始执行具体的动作。

2. 遥控器场景：灯泡有开跟关两个命令，需要交给遥控器来触发invoke，遥控器invoke命令后，命令对象触发包含的灯泡接收对象执行相关指令。

- 适用场景：

1.队列：如一个工作队列，你在一端添加命令，然后另一端则是线程。线程用于从队列中取出一个命令并调用它的执行方法，调用完成丢弃。

2.日志请求：将执行动作记录在日志中，在系统死机之后，重新调用这些动作。
![avatar](https://images0.cnblogs.com/blog/300932/201310/29231031-a9012ec0f1404c9f8b1432f7b85594b9.png)

### 适配器模式
- 定义：定义将一个类的接口，转换成客户期待的另一个接口。适配器让原本接口不兼容的类可以合作无间。
- 只适合做单方向的适配，如三极插头转换成二极。
- java中的适配器应用：1.迭代器的使用，为了兼容旧的使用枚举器的接口，使用适配器进行转换。
![avatar](https://img2018.cnblogs.com/blog/1272523/201901/1272523-20190129143223087-243785080.png)

### 外观模式
- 定义：提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。
- 简单的理解就是对多个接口进行封装，对外统一暴露接口，隐藏内部接口。
![avatar](https://images2018.cnblogs.com/blog/1018770/201805/1018770-20180516222046525-864875223.png)

### 模板方法模式
- 定义：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板模式使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。
- 例子：咖啡店煮咖啡都是有相同的模板跟步骤的，比如都要烧水，选咖啡豆，煮咖啡，将咖啡倒入杯子中。那么可以将模板的步骤定义到抽象的父类中，并提供公共的方法如烧开水、将咖啡倒入杯中。提供公共的钩子，让子类实现，再与实际的操作模板挂钩。
- 容易与策略混淆，区别为模板方法有定义一个算法的大纲，子类再具体实现步骤。而策略是根据不同策略提供子类不同的行为。
![avatar](https://img2018.cnblogs.com/i-beta/898240/201911/898240-20191120150741079-1083249750.png)

### 迭代器模式
- 定义：提供一个方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。
- 例子：一个对象中的元素为数组表示，而另一个对象中为list。让两个对象实现接口，提供统一的构造器。使用时便可以屏蔽实际的数据类型，使用统一的数据模式进行访问。
![avatar](https://www.runoob.com/wp-content/uploads/2014/08/iterator_pattern_uml_diagram.jpg)

### 组合模式
- 定义：允许你将对象组合成属性结构来表现“整体、部分”的层次结构，组合能让客户以一致的方式处理个别对象及对象组合。
- 例子： 一个菜单组件包含菜单项还有子菜单，但是菜单展示的时候，希望可以统一处理，服务员读菜单的时候直接把菜单组件当成一个整体，能统一的读出所有菜单项。
![avatar](https://pics5.baidu.com/feed/a9d3fd1f4134970aaa3b00725b71f9cda6865d67.jpeg?token=2a84b74d0bcf059636a4e5bcb017a283&s=7AA83462119F65CC5CF511CA0000A0B1)

### 状态模式
- 定义：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
- 例子： 糖果机经历投入硬币、转扳手、滚出糖果的三个状态，每个状态都需要执行不同的行为。
- 与策略模式容易混淆，策略主要是针对行为的改变，对于对象是一部分行为的改变。而状态模式针对的则是对象整体行为的改变，两个模式的意图不一致。
![avatar](https://www.runoob.com/wp-content/uploads/2014/08/state_pattern_uml_diagram.png)
![avatar]()

### 代理模式
- 定义：为一个对象提供一个替身或者占位符以控制这个对象的访问。代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象。
- 与装饰者模式容易混淆，主要是行为跟意图的不同，代理主要是为了在对象调用时提供一个额外的保护或者加上其他的动作。而装饰者则是对象调用前，加上额外的行为。
- 代理模式有三种，1.静态代理。2.JDK动态代理（基于接口）3.cglib动态代理（可基于类）


